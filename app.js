const path = require('path'); 

require('dotenv').config();  

const fs=require('fs');//cho ph√©p file system operations theo c√°c d·∫°ng sync, async (callback, promise-based)
const https=require('https'); //kh√¥ng c·∫ßn, v√¨ deploy l√™n Heroku th√¨ n√≥ h·ªó tr·ª£ h·∫øt


const express = require('express'); //create Express application

const morgan = require('morgan'); //ƒë·ªÉ theo d√µi lu·ªìng ch·∫°y c·ªßa t·ª´ng req t·ªõi, nghƒ©a l√† khi hi·ªÉn th·ªã h√¨nh th√¨ server log ra terminal: GET /public/khoHinhPublic/image-22-08-2022-install_React.PNG 200 8.879 ms

//const bodyParser = require('body-parser'); //kh√¥ng c·∫ßn, do ch·ª©c nƒÉng n√†y ƒë√£ c√≥ trong express.urlencoded()
var cookieParser=require('cookie-parser');   //c√≥ v·∫ª kh√¥ng c·∫ßn thi·∫øt

const mongoose = require('mongoose'); //1 high vulnerability ·ªü express-session
const session = require('express-session');
//Settings object for the session ID cookie. The default value is { path: '/', httpOnly: true, secure: false, maxAge: null }.
//The following are options that can be set in this object. Example (xem K·∫øt qu·∫£ c·∫ßn ƒë·∫°t) cookie.secure

//L∆∞u tr·ªØ session tr√™n MongoDB
const MongoDBStore = require('connect-mongodb-session')(session); //https://stackoverflow.com/questions/6819911/node-js-express-js-session-handling-with-mongodb-mongoose
//‚ö†Ô∏èWarning: default server-side session storage, MemoryStore, is purposely NOT designed for a production environment. It will leak memory under most conditions, does not scale past a single process, and is meant for debugging and developing.
//üëâ List of compatible session:  https://www.npmjs.com/package/express-session#compatible-session-stores

//const csrf = require('csurf');//ch·ªëng l·∫°i csrf attacks
const flash = require('connect-flash');
const methodOverride = require('method-override');
//crypto ƒë·ªÉ sau n√†y generate the unique filename. ƒê√¢y c≈©ng l√† core nodejs module
const crypto=require('crypto');

const helmet=require('helmet'); //helps in securing HTTP headers (https://www.geeksforgeeks.org/node-js-securing-apps-with-helmet-js/)
//node asset compression middleware üëâ https://github.com/expressjs/compression
const compression= require('compression'); //gi·∫£m kh·ªëi l∆∞·ª£ng n·ªôi dung (response body) ƒë∆∞·ª£c server g·ª≠i cho client, nh∆∞ng never compress responses c√≥ Cache-Control headers

const errorController = require('./controllers/error');
const User = require('./models/user'); //WHY? v√¨ entry point app.js l√† 1 big controller, do ƒë√≥ n√≥ c√≥ th·ªÉ g·ªçi c√°c controller con v√† model lu√¥n

//d√πng template string ch·ª©a c√°c dynamic value (bi·∫øn hay expression)
/*
  Node's process object, this is an object not defined by us but this is globally available (accessible) in the node app (it's part of the node core runtime.)
*/
/*
Now on this process object, we have the very helpful env property and that is now an object with all the

environment variables
*/
//process.env l√† object ch·ª©a t·∫•t c·∫£ c√°c environment variables that Node knows
//a bunch of default environment variables but we can also set our own ones
//environment variable nh∆∞ process.env.MONGO_USER
//you could of course make that WHOLE connection string (ph·ªï bi·∫øn nha) an environment variable
//Nh∆∞ng c∆° s·ªü ƒë·ªÉ l·ª±a ch·ªçn l√†: depending on whether that string changes regularly or just the values inside of it

//const MONGODB_URI ='mongodb+srv://lyvietkhang_admin:FLC0EfhTqJHonvsI@khangserver0.w0azxjp.mongodb.net/testMongoose';
const MONGODB_URI =`mongodb+srv://${process.env.MONGO_USER}:${process.env.MONGO_PASSWORD}@khangserver0.w0azxjp.mongodb.net/${process.env.MONGO_DEFAULT_DATABASE}`;
console.log(MONGODB_URI);
//t·∫°o conn c√≥ th·ªÉ t√°i s·ª≠ d·ª•ng ƒë·ªÉ gi√∫p gridFS 


//highlight one special environment variable. Th∆∞·ªùng c√°c vd tr√™n m·∫°ng s·∫Ω cho th·∫•y g√°n gi√° tr·ªã l√† "development" v√†o
console.log(process.env.NODE_ENV); 

const app = express();  //const app = require('express')();

//h·ªó tr·ª£ DELETE c√≥ th·ªÉ d√πng app.delete() v·ªõi form method='POST'
app.use(methodOverride('_method'))
app.use(cookieParser()); 
   //TRAP: ƒëo·∫°n code v·ª´a r·ªìi t·∫°o cookie-parser middleware v√† kh√¥ng d√πng secret n√†o, v√¨ Using cookie-parser may result in issues if the secret is not the same between this module and cookie-parser. ·ªû ƒë√¢y ch·ªâ d√πng cookieparser cho vi·ªác ƒë·ªçc cookie
   //REALITY: session() creates a express's session middleware which now directly reads and writes cookies on req/res
   //c√°ch d√πng: https://www.geeksforgeeks.org/how-to-access-http-cookie-in-node-js/. 
   //L∆∞u √Ω c√°ch d√πng cookie-parser: vi·ªác t·∫°o cookie middleware  cookieParser(secret, options) c√≥ th·ªÉ g√¢y issue v·ªõi session v·ªÅ thu·ªôc t√≠nh secret üëâ https://www.npmjs.com/package/express-session
app.use(morgan('dev'));//ƒë·ªÉ d·ªÖ theo d√µi ƒë∆∞·ªùng ƒëi c·ªßa req. r·∫•t quan tr·ªçng

//t·∫°o ƒë·ªëi t∆∞·ª£ng ConnectMongoDBSession.MongoDBStore
const store = new MongoDBStore({
    //uri: process.env.MONGODB_URI,
    uri: MONGODB_URI, 
    collection: 'sessions'  //‚úçÔ∏è ƒë·ªëi t∆∞·ª£ng c·∫ßn l∆∞u s·∫Ω n·∫±m trong collection "sessions". Nh∆∞ng trong source code th√¨ ƒë·ªëi t∆∞·ª£ng n√†y l√† session
});

//const csrfProtection = csrf();

//I will read in my private key by using the node file system package
//you can read a file synchronously.  this will block code execution until the file is read . that typically, this is not what you want to do
//but here I actually don't want to continue with starting the server unless I have read that file in.
//So here I will read that file synchronously
// I want to read is server.key, fieldso my private key file.

// const privateKey=fs.readFileSync('server.key');
// const certificate=fs.readFileSync('server.cert');

//Now with these two files read in, we can scroll down to the place where we start the server with app.listen 


mongoose.set('debug', true); //Mongoose debug logging VD: signup th√¨ mongoose s·∫Ω log User.findById()
//mongoose was built on mongoDB driver module
//Mongoose's change tracking sends a minimal update to MongoDB based on the changes you made to the document. You can set Mongoose's debug mode to see the operations Mongoose sends to MongoDB.

//https://www.geeksforgeeks.org/how-to-setup-view-engine-in-node-js/
app.set('view engine', 'ejs'); //t·ª± ƒë·ªông t√¨m th∆∞ m·ª•c views , n√™n kh√¥ng c·∫ßn thi·∫øt app.set('views', 'views');
app.set('views', path.join(__dirname, 'views')) 
console.log("B√≠ m·∫≠t path.join : \n",path.join(__dirname, 'views')); //path.join(ch·ª©a c√°c path to be joined) t·ª´ th∆∞ m·ª•c hi·ªán t·∫°i (__dirname) join the relative path "views"
//app.set('views', 'views');//https://stackoverflow.com/questions/69445254/is-path-join-dirname-views-no-longer-needed-for-rendering-ejs
//path.join(__dirname, relative_path)

//Dynamic Port Setup, ƒë√≤i h·ªèi ph·∫£i c√≥ khi deploy l√™n HEROKU 
app.set('port', process.env.PORT || 5000);  //d·∫°ng app.set(name,value) v·ªõi value m√† PORT l√† undefined, ph·∫£i c√≥ process.env

//now Hook routers up inside of Express server, then we can app.use(router)
const adminRoutes = require('./routes/admin');
const shopRoutes = require('./routes/shop');
const authRoutes = require('./routes/auth');

//maybe helemt will be in the place where we then also set up all our other middleware
//ƒë√≥n incoming requests th√¨ kh√¥ng c√≥ g√¨ n√≥i v√¨ n√≥ l√† middleware; ƒê√°ng n√≥i l√† n√≥ ph·∫£i ƒë·ª©ng tr∆∞·ªõc t·∫•t c·∫£ controller trong routes v√¨ protect v·ªõi c√°c special headers
app.use(helmet());
app.use(compression());

//req.body is not defined by default, it is used to parse encoded-in-url text (comes from form submitting) into JS object of text, cannot parse file of binary data into text inside JS object
//app.use(bodyParser.urlencoded({ extended: false })); //thay th·∫ø l√† app.use(express.urlencoded({ extended: false }))
app.use(express.urlencoded({ extended: false }))
app.use(express.json());

app.use(express.static(path.join(__dirname, 'public'))); 
     //‚úÖhttp://localhost:3005/bg_grass.PNG
     //‚úÖhttp://localhost:3005/khoHinhPublic/bg_grass.PNG
     //üéâLesson: t∆∞∆°ng ƒë∆∞∆°ng application-level route (use/get/post) trong ƒë√≥ filename is very dynamic!

//path.join gi√∫p t·∫°o absolute path cho static resources, kh√¥ng ph·ª• thu·ªôc __dirname l√† n∆°i current running Node process ƒëang ·ªü ƒë√¢u c≈©ng ƒë∆∞·ª£c ! VD c√°c absolute path sau src="/css/auth.css" üß° http://localhost:3000/css/auth.css  (Note: kh√¥ng li√™n quan g√¨ app.use('/admin,...) v√¨ ch·ªó n√†y kh√¥ng server static files)
//app.use('/images',express.static(path.join(__dirname, 'images'))); //now if URL has path prefix /images, Express also serve the images static folder , Example üß° http://localhost:3000/images/image-22-8-2022-data_fetched.PNG
//app.use(express.static('images'));  hay app.use(express.static(path.join(__dirname, 'images'))); //NOT üñ§ http://localhost:3000/images/image-22-8-2022-data_fetched.PNG , but üß° http://localhost:3000/image-22-8-2022-data_fetched.PNG


app.use('/public',express.static(path.join(__dirname, 'public'))); //ƒê√ÇY L√Ä B√ç QUY·∫æT GI√öP D√ôNG multer's path ƒë·ªÉ g·∫Øn v√†o src

app.use(express.static(path.join(__dirname, 'images'))); 
//This technique can come in handy when providing multiple directories as static files. These prefixes can help distinguish between multiple directories.
//https://stackoverflow.com/questions/51366832/do-you-use-express-static-public-or-path-join-dirname-public
//Since you are using express.static, which is the first middleware in your code, requests that match the files in the static folder will be handled by express.static. The files in .well-known probably do not have a .json extension, hence the content type will be inferred as application/octet-stream as this is the default.


app.use(
  // t·∫°o session ch·ª©a cookie th√¥i
    ///k·∫øt qu·∫£: do ƒë√≥ ngay t·ª´ brand-new req ƒê·∫¶U TI√äN t·ªõi the first app.use((req, res, next) 
      //// th√¨ req L∆ØU bi·∫øn sessionID, v√† ƒë·ªëi t∆∞·ª£ng Session ch·ª©a ƒë·ªëi t∆∞·ª£ng cookie (ch∆∞a c√≥ value n√†o) 
      //// khi res trang web hay cho d√π res trang b√°o l·ªói 500 th√¨ res g·ª≠i 1 response cookie  v√†o browser
    /// v·ªõi brand-new req TH·ª® HAI th√¨ browser ch·ªß ƒë·ªông ƒë·ªçc response cookie  v√† g·ª≠i b·∫£n copy c·ªßa cookie b√™n trong req  
  session({
    secret: 'my secret',  //secret used to sign the session cookie --> https://www.npmjs.com/package/cookie-parser
    resave: false, //if true, the session is forced to be saved back to session store
    saveUninitialized: false, //https://stackoverflow.com/questions/68841518/storing-sessions-with-express-session-connect-mongo-and-mongoose

    //T·∫°i sao c·∫ßn store??
    //Also if you don‚Äôt use something like redis of mongo, all your memory will get eaten up. Express-session isn‚Äôt built for production environments.
    //D√πng MongoStore ƒë·ªÉ l∆∞u session v√†o MongoDB
    store: store    //do ƒë√≥ ngay t·ª´ brand-new req t·ªõi app.use((req, res, next)  ƒë·∫ßu ti√™n, ƒë√£ c√≥ bi·∫øn sessionStore
    //ƒë·ªëi t∆∞·ª£ng cookie ƒëang mang c√°c gi√° tr·ªã m·∫∑c ƒë·ªãnh, c√≥ th·ªÉ setting m·ªõi cho n√≥ ·ªü ƒë√¢y https://www.npmjs.com/package/express-session
    //üíõ cookie: { secure: true }   //m·∫∑c ƒë·ªãnh cookie:{secure:null, v√† c√°c thu·ªôc t√≠nh kh√°c} 
    //By default, the Secure attribute is not set with falsy . When truthy, the Secure attribute is set, otherwise it is not
    //üíõ Please note that secure: true is a recommended option. However, it requires an https-enabled website, i.e., HTTPS is necessary for secure cookies. If secure is set, and you access your site over HTTP, the cookie will not be set. If you have your node.js behind a proxy and are using secure: true, you need to set "trust proxy" in express: app.set('trust proxy', 1) // trust first proxy
  })
);
//app.use(csrfProtection);  //t·∫°o bi·∫øn csrf trong session


app.use(flash());

//req m·ªõi, nh∆∞ng n·∫øu t√¨m th·∫•y session th√¨ l√† user c≈© ch∆∞a log out
//VD h√†nh tr√¨nh c·ªßa user ch∆∞a ƒëƒÉng nh·∫≠p l√†: GET req  '/' -->GET req  '/login' --> GET req '/admin/edit-product' --> GET req '/admin/products' --> '/login'
  /// '/' th√¨ req A v·ªõi !reqA.session.user , th√¨ session ch·ª©a cookie ƒë√£ c√≥ tr√™n server (tr√™n MongoDB kh√¥ng c√≥ req.session.user n√†o)
  /// '/login'th√¨ req B v·ªõi !reqB.session.user (tr√™n MongoDB kh√¥ng c√≥ req.session.user n√†o)
  /// '/admin/edit-product' th√¨ req C v·ªõi !reqC.session.user (tr√™n MongoDB kh√¥ng c√≥ req.session.user n√†o) nh·∫≠n ƒë∆∞·ª£c n·ªôi dung trang n√†y l√† "Page Not Found!" 
  /// '/admin/products' th√¨ req D v·ªõi !reqD.session.user (tr√™n MongoDB kh√¥ng c√≥ req.session.user n√†o) [V√Ä G·∫∂P PH·∫¢I CSRF PROTECTION TRONG FORM n√™n b·ªã res.redirect t·ªõi '/login']
  /// Ti·∫øp theo, user n√†y quy·∫øt ƒë·ªãnh ƒëƒÉng nh·∫≠p th√†nh c√¥ng => so tr√πng email v√† t√¨m ƒë∆∞·ª£c model user => t·∫°o req.session.user (v·ªõi c√°c mongoose magic methods) l·∫´n req.session.isLoggedIn
  /// '/' v·ªõi req E , nh∆∞ng l·∫ßn n√†y ƒë√£ ƒë√°nh gi√° ƒë∆∞·ª£c req.session.user._id n√™n reqE.user=user aka req m·ªõi user c≈©
  /// '/admin/add-product/' v·ªõi req F,  ƒë√£ ƒë√°nh gi√° ƒë∆∞·ª£c req.session.user._id n√™n reqF.user=user  aka req m·ªõi user c≈©



app.use((req, res, next) => {
  //console.log("N·∫øu l·∫ßn ƒë·∫ßu t·ªõi website, client ch∆∞a l∆∞u cookie th√¨ req ch·ª©a nh·ªØng g√¨? \n",req) 
  //ho·∫∑c xem Dev tool >> Network nh∆∞ng ch·ªâ c√≥ request headeders
  //dƒ© nhi√™n GET req th√¨ body:{}

  //if l√† k·ªπ thu·∫≠t tr√°nh b√°o l·ªói ReferenceError n·∫øu session.user kh√¥ng t·ªìn t·∫°i
      //Ngo√†i ra n·∫øu session.user kh√¥ng t·ªìn t·∫°i m√† d√πng Model ƒë·ªÉ find l√† l√†m crash app

  //tr∆∞·ªõc kia ƒë√£ g√°n user cho req.session r·ªìi req.session.save() v√†o CSDL th√¨ user ƒë∆∞·ª£c l∆∞u trong MongoStore 
  //B√¢y gi·ªù kh√¥ng ph·∫£i g√°n m√† l√† truy xu·∫•t : https://stackoverflow.com/questions/51731771/node-js-how-to-save-a-users-shopping-cart-in-express-session
  
  //Dƒ® NHI√äN C√ì req.session v√¨ req ƒëi qua middleware session(), nh∆∞ng c√¢u h·ªèi l√† c√≥ req.session.user hay kh√¥ng
  if (!req.session.user) {  //WHY? TRONG PHP HAY EXPRESS, TR∆Ø·ªöC KHI L·∫§Y GI√Å TR·ªä BI·∫æN SESSION PH·∫¢I XEM SESSION C√ì T·ªíN T·∫†I KH√îNG (c≈©ng ƒë·ªìng nghƒ©a ng∆∞·ªùi d√πng log out ch∆∞a)
    //TR∆Ø·ªúNG H·ª¢P 0: if (!req.session) th√¨ app.use(cookieParser) s·∫Ω l√†m stuck tr√¨nh duy·ªát. Solution 1 l√† ph·∫£i ghi if(!req.session.user); Solution 2 l√† cho app.use(cookieParser) n·∫±m ph√≠a sau middleware ch·ª©a if(!req.session.user)
    //TR∆Ø·ªúNG H·ª¢P 1: CLIENT CH·ª®A COOKIE --> n·∫øu ghi if (!req.session) th√¨ l√† if(false) v√† kh√¥ng tho√°t h√†m, b·ªã catch l·ªói TypeError: Cannot read properties of undefined (reading '_id')
    //TR∆Ø·ªúNG H·ª¢P 2: CLIENT KH√îNG CH·ª®A COOKIE --> n·∫øu ghi if (!req.session) th√¨ l√† if(true)
    //2 TR∆Ø·ªúNG H·ª¢P TR√äN L√Ä SAI v√¨ b·∫•t c·ª© req n√†o tr∆∞·ªõc khi t·ªõi middleware n√†y ƒë·ªÅu ƒë∆∞·ª£c express app g·∫Øn session v√†o req
    //how to extract cookie t·ª´ req, v√¨ req ch·ª©a t√™n object l√† [Symbol(kHeaders)] kh√¥ng r√µ r√†ng ƒëang ch·ª©a cookie
       ///https://stackoverflow.com/questions/51812422/node-js-how-can-i-get-cookie-value-by-cookie-name-from-request

    //I TRY TO GET user OUT OF session
    //req.session.user l·∫´n req.session.isLoggedIn ƒë∆∞·ª£c t·∫°o ra l√∫c n√†o? exports.postLogin n·∫øu ƒëƒÉng nh·∫≠p th√†nh c√¥ng
 
    //I have a solution for session.user inexistence: because if I would not add this check, then I could try to find a user without the session.user OBJECT existing and that would then crash our app . Why? nh·ªõ l·∫°i n·∫øu user.name th√¨ user c√≥ m√† name kh√¥ng c√≥ th√¨ kh√¥ng crash, c√≤n user m√† undefined th√¨ REFERENCE Error: user is not defined
    return next(); //ok, hi·ªán kh√¥ng c√≥ session n√†o ƒë·ªëi v·ªõi m√°y client cookie n√†y, th√¨ req s·∫Ω kh√¥ng ƒë∆∞·ª£c g√°n req.user v√† s·∫Ω t·ªõi middleware k·∫ø ti·∫øp
    //tho√°t h√†m (nghƒ©a l√† code ti·∫øp theo s·∫Ω unreachable, kh√¥ng cho ch·∫°y ra ngo√†i if) v√† nh·∫£y t·ªõi middleware k·∫ø ti·∫øp
  }

  //console.log("req c√≥ ch·ª©a thu·ªôc t√≠nh cookies?? C√≥, trong rawHeaders \n",req); 
  console.log("req cookie:\n",req.cookies); //ok, nh∆∞ng req.cookies l√† dƒ© nhi√™n c√≥, ƒë√¢u c·∫ßn cookieParser?
  User.findById(req.session.user._id)  //idea l√† d√πng session d·ªÖ truy c·∫≠p ƒë·ªÉ ch·∫°y h√†m Mongoose, k·∫øt qu·∫£ ra mongoose model c√≥ th·ªÉ th·ª±c hi·ªán magic
    //for some reason, we might still not find that user (undefined) in database (s·∫Ω g√¢y app crash ?? NO v√¨ ƒë√¢y kh√¥ng ph·∫£i database technical problem , do ƒë√≥ c√≥ nguy c∆° g√¢y ra store undefined object trong req, khi ƒë√≥ console.log(req.user) s·∫Ω g√¢y app crash v√¨ ReferenceError) even if we have it stored in a session, maybe because the user was deleted in a database in-between.
    .then(user => {  //Khi t√¨m th·∫•y session t·ª©c l√† ng∆∞·ªùi d√πng ch∆∞a logout (v√¨ logout l√† session.destroy )
        if(!user){
            return next(); // we are super safe that we don't store some undefined object in the req.user (v√¨ s·∫Ω b√°o l·ªói n·∫øu undefined g·ªçi h√†m). Nh∆∞ng but that we continue without the user instead if we can't find the user (promise tr·∫£ v·ªÅ undefine).
        }
        req.user = user; //m·ª•c ƒë√≠ch ƒë·ªÉ s·ª≠ d·ª•ng Mongoose magic methods (l√Ω do l√† req.session.user tr√™n MongoDB ch·ªâ l∆∞u data th√¥i, kh√¥ng c√≥ l∆∞u h√†m _ th·∫ßy NTHuy c≈©ng n√≥i). ƒê·ªùi s·ªëng c·ªßa session.user b·∫Øt ƒë·∫ßu ·ªü login th√†nh c√¥ng v√† ƒë∆∞·ª£c k·∫ø th·ª´a ·ªü ngay l√∫c v√†o trang ch·ªß
        
        next();
    })
    //catch block v·ªõi log th√¨  not really useful though
    //.catch(err => console.log("ƒê√£ ph√°t hi·ªán l·ªói: \n",err)); //again we're not working with technical error objects here
    /*
        catch r·∫•t hay b·∫Øt err n√™n err ·ªü ƒë√¢y ho·∫∑c t·ªìn t·∫°i ho·∫∑c undefined
        because it's really important, this catch block will not fire if I don't find the user with this ID
        it will only fire if there are any TECHnical issues you could say, if the database is down or if the
        user of this app does not have sufficient permissions to execute this action.
    */
    .catch(err=>{
        //N·∫øu kh√¥ng c√≥ error object th√¨ err is undefined 
        //N·∫øu c√≥ error object,  It will make more sense to throw a new error here where we simply wrap the error object we get
        //proactively Throwing this error has a significant advantage which I will show you in a second
        //tr∆∞·ªõc kia tham s·ªë c·ªßa builtin Error class function l√† 1 message string, gi·ªù l√† 1 err object 
        // if we do have some technical issue regarding database, we throw a real error
        throw new Error(err);
        //Why I do like this??  as it turns out, expressjs gives us a way of taking care of such errors, that is why I'm doing it like this.
        /*
            Alternatively to error throwing, we could of course also simply call next here to continue without req.user being set (gi·∫£i quy·∫øt nh∆∞ user undefined) or anything like that
            next()
            but I want to throw an error because we had a technical issue connecting to our database and that is something that might be a bigger problem than just a non-existing user (Tui kh√¥ng mu·ªën b·ªè qua n√≥)
       */
    })
});


app.use((req, res, next) => {
  console.log("Hi, khi v·ª±c c·ªßa locals object!")
  //https://www.geeksforgeeks.org/express-js-res-locals-property/
      /// it is only available to the view(s) rendered during that request/response cycle (if any).

  //ƒê·ªëi t∆∞·ª£ng locals hay n·∫±m b√™n trong res (xem h√¨nh trong K·∫øt qu·∫£ c·∫ßn ƒë·∫°t)
  res.locals.isAuthenticated = req.session.isLoggedIn; //v·∫ø ph·∫£i ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a t·∫°i exports.postLogin n·∫øu ƒëƒÉng nh·∫≠p th√†nh c√¥ng
  //res.locals.csrfToken = req.csrfToken();//n·∫øu ƒëang logout status m√† v√†o /admin/add-product th√¨ s·∫Ω b·ªã t·ªõi trang b√°o l·ªói: invald csrf token
  next();
});



//ok, v·ªõi client cookie c√≥ session t∆∞∆°ng ·ª©ng tr√™n server, th√¨ req ƒë√≥ s·∫Ω c√≥ req.user üëâ c√≥ th·ªÉ d√πng req.user trong c√°c controllers
//client cookie t·ªõi m√† kh√¥ng c√≥ session t∆∞∆°ng ·ª©ng th√¨ req kh√¥ng mang g√≥i th√¥ng tin user n√†o
app.use('/admin', adminRoutes); //req b·∫Øt bu·ªôc ph·∫£i qua absolute path "/admin" (g·∫Øn tr·ª±c ti·∫øp v√†o computer address http://localhost:port)
app.use(shopRoutes); //ok. c√°c anh req kh√¥ng c√≥ req.user c√≥ th·ªÉ v√†o Shop ƒë·ªÉ tham quan. c√≤n chuy·ªán add-to-cart s·∫Ω b·ªã middleware is-auth ch·∫∑n l·∫°i, th·∫≠m ch√≠ x·ª≠ l√Ω hi·ªÉn th·ªã theo role kh√¥ng cho xem option Add Product nh∆∞ng anh req_no_user n√†o c·ªë g·∫Øng g√µ /admin/add-product c≈©ng s·∫Ω b·ªã is-auth ch·∫∑n l·∫°i
app.use(authRoutes);

//maybe helemt will be in the place where we then also set up all our other middleware
//ƒë√≥n incoming requests
//app.use(helmet()); üëà‚ö†Ô∏è V·ªã tr√≠ n√†y l√† sau c√°c response c·ªßa c√°c controllers , k·∫øt qu·∫£ l√† res header kh√¥ng c√≥ headers ƒë·∫∑c bi·ªát n√†o c·ªßa helmet! üòé

//res.redirect('/500');. M·∫•y anh middleware n√†y hay b·∫Øt l·ªói n√™n code ƒë·ªÉ cu·ªëi 



//x·ª≠ l√Ω l·ªói l√† b·ªüi c√°c middlewares cu·ªëi c√πng
app.use('/500',errorController.get500); //v√¨ sao c√≥ path prefix /500 hay kh√¥ng c√≥ th√¨ v·∫´n kh√¥ng t·ªõi get500 ƒë∆∞·ª£c??
app.use(errorController.get404);

//middleware error handler
// app.use((err,req,res,next)=>{
//   console.log("I got exception")
//   res.status(err.status || 500);
//   res.render('error',{
//       message: err.message,
//       error:err
//   });
// })  


/*
First, we need to define a connection. If your app uses only one database, you should use mongoose.connect. If you need to create additional connections, use mongoose.createConnection.

Both connect and createConnection take a mongodb:// URI
*/

mongoose
  //.connect(process.env.MONGODB_URI)
  .connect(MONGODB_URI)
  /*
  //https://fatihkalifa.com/express-crash-mongodb-fix
  I didn't know that mongoose.connect returns an object with connection property that behaves like EventEmitter. This connection property can listen to various events like error, disconnected, and open.
  */
  .then(result => {
    //n·∫øu process.env.PORT undefined th√¨ m·∫∑c ƒë·ªãnh l·∫•y 3000
    //khi server c·∫ßn ƒë·ªçc private key v√† certificate ƒë·ªãnh danh c·ªßa m√¨nh
    //kh√¥ng d√πng app.listen n·ªØa
    //d√πng https.createServer to create a https server, this function takes 2 arguments: 
        ///2 arguments
        /// the first one configures the server
            //// here we have to point it at our private key
            //// a javascript object where you need to set two things:
                ///// privateKey
                ///// certificate
        /// the second argument will be our request handle
            ////in our case our express application
    // https.createServer({key:privateKey , cert:certificate},app)
    //      .listen(app.get("port"),function(error){ //n·∫øu .listen(port) th√¨ ReferenceError (th∆∞·ªùng th·∫•y cho bi·∫øn let b·ªã g·ªçi m√† tr∆∞·ªõc ƒë√≥ ch∆∞a ƒë∆∞·ª£c g√°n gi√° tr·ªã n√†o h·∫øt): port is not defined
                app.listen(app.get("port"),err=>{
                  if(err) throw err;
                
                  console.log("Express app has just been listening on port: "+app.get("port"))
                }); 
                
          //});
          //https://www.geeksforgeeks.org/how-to-setup-view-engine-in-node-js/
          //K·∫øt qu·∫£: http://localhost:3000/ s·∫Ω The page is not working v√¨ http
  })
  .catch(err => {
    //https://stackoverflow.com/questions/50241066/how-to-get-node-to-exit-when-mongo-connect-fails
    console.log("we found some error: \n",err); //Kh√¥ng b·∫Øt l·ªói app m√† b·∫Øt l·ªói mongooseConnection, do ƒë√≥ trong app.listen ph·∫£i th·ª±c hi·ªán error handling
    process.exit(1);  //I've already handled the error case by exiting the process if there is an error. So if there is an error, the app will quit
  });
